/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPSERT_TRANSLATION_HPP
#define _UPSERT_TRANSLATION_HPP

#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "flatbuffers/util.h"
#include "json.hpp"
#include "rocksDBWrapper.hpp"
#include "translation_generated.h"

constexpr auto TRANSLATION_DATABASE_PATH {"queue/vd/translations"};
const std::string FLATBUFFER_PATH {FLATBUFFER_SCHEMAS_DIR "translation.fbs"};
const char* INCLUDE_DIRECTORIES[] = {FLATBUFFER_SCHEMAS_DIR, nullptr};

/**
 * @brief UpsertTranslation class.
 *
 */
class UpsertTranslation
{
private:
    /**
     * @brief Inserts a translation entry in a rocksdb database.
     *
     * @param data JSON with the required information to create or update a translation entry.
     * @param rocksDbWrapper rocksdb wrapper instance.
     */
    static void insertTranslationEntry(const nlohmann::json& data, Utils::RocksDBWrapper& rocksDbWrapper)
    {
        std::string translationEntryStr;
        if (rocksDbWrapper.get(data.at("resource").get<std::string>(), translationEntryStr))
        {
            std::cerr << "Key already exists." << std::endl;
        }
        else if (data.contains("payload"))
        {
            std::string flatbufferSchemaStr;
            bool valid = (flatbuffers::LoadFile(FLATBUFFER_PATH.c_str(), false, &flatbufferSchemaStr));
            if (!valid)
            {
                std::cerr << "Couldn't open flatbuffer schema: " << FLATBUFFER_PATH << std::endl;
            }

            const std::string payload = data.at("payload").dump();
            const std::string resource = data.at("resource").get<std::string>();
            flatbuffers::Parser parser;

            valid = (parser.Parse(flatbufferSchemaStr.c_str(), INCLUDE_DIRECTORIES) && parser.Parse(payload.c_str()));
            if (!valid)
            {
                std::cerr << "Error: " << parser.error_ << std::endl;
            }

            uint8_t* buf = parser.builder_.GetBufferPointer();
            size_t flatbufferSize = parser.builder_.GetSize();

            const rocksdb::Slice translationSlice(reinterpret_cast<const char*>(buf), flatbufferSize);
            rocksDbWrapper.put(resource, translationSlice);
        }
        else
        {
            std::cerr << "No payload data" << std::endl;
        }
    }

    /**
     * @brief Updates a translation entry in a rocksdb database.
     *
     * @param data JSON with the required information to create or update a translation entry.
     * @param rocksDbWrapper rocksdb wrapper instance.
     */
    static void updateTranslationEntry(const nlohmann::json& data, Utils::RocksDBWrapper& rocksDbWrapper)
    {
        std::string translationEntryStr;
        if (rocksDbWrapper.get(data.at("resource").get<std::string>(), translationEntryStr))
        {
            const std::string resource = data.at("resource").get<std::string>();
            std::string flatbufferSchemaStr;
            flatbuffers::LoadFile(FLATBUFFER_PATH.c_str(), false, &flatbufferSchemaStr);
            flatbuffers::Parser parser;
            parser.opts.strict_json = true;

            bool valid = parser.Parse(flatbufferSchemaStr.c_str(), INCLUDE_DIRECTORIES);
            if (!valid)
            {
                std::cerr << parser.error_ << std::endl;
            }

            std::string translationEntry;
            flatbuffers::GenText(parser, translationEntryStr.c_str(), &translationEntry);

            try
            {
                nlohmann::json translationEntryJSON = nlohmann::json::parse(translationEntry);
                nlohmann::json translationEntryJSONPatched = translationEntryJSON.patch(data.at("operations"));
                std::string translationEntryJSONPatchedStr = translationEntryJSONPatched.dump();
                valid = parser.Parse(translationEntryJSONPatchedStr.c_str());

                if (!valid)
                {
                    std::cerr << parser.error_ << std::endl;
                }

                uint8_t* buf = parser.builder_.GetBufferPointer();
                size_t flatbufferSize = parser.builder_.GetSize();

                const rocksdb::Slice translationSlice(reinterpret_cast<const char*>(buf), flatbufferSize);
                rocksDbWrapper.put(resource, translationSlice);
            }
            catch (...)
            {
                std::cerr << "Couldn't update translation entry id: " << resource << std::endl;
            }
        }
    }

public:
    /**
     * @brief Creates or modifies a translation entry in a rocksdb database.
     *
     * @param data JSON with the required information to create or update a translation entry.
     * @param rocksDbWrapper rocksdb wrapper instance.
     */
    static void upsertTranslationEntry(const nlohmann::json& data, Utils::RocksDBWrapper& rocksDbWrapper)
    {
        if (data.contains("data"))
        {
            for (const auto& item : data.at("data"))
            {
                if (item.contains("type") && item.contains("resource"))
                {
                    if (item.at("type").get<std::string>().compare("create") == 0)
                    {
                        insertTranslationEntry(item, rocksDbWrapper);
                    }
                    else if (item.at("type").get<std::string>().compare("update") == 0)
                    {
                        updateTranslationEntry(item, rocksDbWrapper);
                    }
                    else
                    {
                        std::cerr << "Invalid operation type: " << item.at("type").get<std::string>() << std::endl;
                    }
                }
                else
                {
                    std::cerr << "Invalid data format" << std::endl;
                }
            }
        }
    }
};

#endif // _UPSERT_TRANSLATION_HPP
