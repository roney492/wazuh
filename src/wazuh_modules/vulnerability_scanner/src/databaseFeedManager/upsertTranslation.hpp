/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPSERT_TRANSLATION_HPP
#define _UPSERT_TRANSLATION_HPP

#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "flatbuffers/util.h"
#include "json.hpp"
#include "rocksDBWrapper.hpp"
#include "translation_generated.h"

constexpr auto TRANSLATION_DATABASE_PATH {"queue/vd/translations"};
const std::string FLATBUFFER_PATH {FLATBUFFER_SCHEMAS_DIR "translation.fbs"};
const char* INCLUDE_DIRECTORIES[] = {FLATBUFFER_SCHEMAS_DIR, nullptr};

class UpsertTranslation
{
public:
    static void upsertTranslationEntry(const nlohmann::json& data, Utils::RocksDBWrapper& rocksDbWrapper)
    {

        if (data.contains("data"))
        {
            for (const auto& item : data.at("data"))
            {
                if (item.contains("type"))
                {
                    if (item.at("type").get<std::string>().compare("create") == 0)
                    {
                        std::string translationEntryStr;
                        if (item.contains("resource") &&
                            rocksDbWrapper.get(item.at("resource").get<std::string>(), translationEntryStr))
                        {
                            std::cerr << "Key already exists." << std::endl;
                        }
                        else if (item.contains("payload"))
                        {
                            std::string flatbufferSchemaStr;

                            bool valid = (flatbuffers::LoadFile(FLATBUFFER_PATH.c_str(), false, &flatbufferSchemaStr));
                            if (!valid)
                            {
                                std::cerr << "Couldn't open flatbuffer schema: " << FLATBUFFER_PATH << std::endl;
                            }
                            const std::string payload = item.at("payload").dump();
                            const std::string resource = item.at("resource").get<std::string>();
                            flatbuffers::Parser parser;
                            valid = (parser.Parse(flatbufferSchemaStr.c_str(), INCLUDE_DIRECTORIES) &&
                                     parser.Parse(payload.c_str()));
                            if (!valid)
                            {
                                std::cerr << "Error: " << parser.error_ << std::endl;
                            }

                            uint8_t* buf = parser.builder_.GetBufferPointer();
                            size_t flatbufferSize = parser.builder_.GetSize();

                            const rocksdb::Slice translationSlice(reinterpret_cast<const char*>(buf), flatbufferSize);
                            std::cout << "Saving entry: " << resource << std::endl;
                            rocksDbWrapper.put(resource, translationSlice);
                        }
                    }
                    else if (item.at("type").get<std::string>().compare("update") == 0)
                    {
                        std::string translationEntryStr;
                        if (rocksDbWrapper.get(item.at("resource").get<std::string>(), translationEntryStr))
                        {
                            std::cout << "Key found " << std::endl;
                            std::string flatbufferSchemaStr;
                            flatbuffers::LoadFile(FLATBUFFER_PATH.c_str(), false, &flatbufferSchemaStr);
                            flatbuffers::Parser parser;
                            parser.opts.strict_json = true;
                            bool valid = parser.Parse(flatbufferSchemaStr.c_str(), INCLUDE_DIRECTORIES);
                            if (!valid)
                            {
                                std::cerr << parser.error_ << std::endl;
                            }
                            std::string translationEntry;
                            flatbuffers::GenText(parser, translationEntryStr.c_str(), &translationEntry);

                            nlohmann::json translationEntryJSON = nlohmann::json::parse(translationEntry);
                            nlohmann::json translationEntryJSONPatched =
                                translationEntryJSON.patch(item.at("operations"));
                            std::string translationEntryJSONPatchedStr = translationEntryJSONPatched.dump();
                            valid = parser.Parse(translationEntryJSONPatchedStr.c_str());
                            if (!valid)
                            {
                                std::cerr << parser.error_ << std::endl;
                            }
                            uint8_t* buf = parser.builder_.GetBufferPointer();
                            size_t flatbufferSize = parser.builder_.GetSize();
                            const std::string resource = item.at("resource").get<std::string>();
                            const rocksdb::Slice translationSlice(reinterpret_cast<const char*>(buf), flatbufferSize);
                            std::cout << "Saving entry: " << resource << std::endl;
                            rocksDbWrapper.put(resource, translationSlice);
                        }
                    }
                }
            }
        }
    }
};

#endif // _UPSERT_TRANSLATION_HPP
